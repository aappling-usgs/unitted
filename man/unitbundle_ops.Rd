% Generated by roxygen2 (4.0.1): do not edit by hand
\docType{methods}
\name{unitbundle_ops}
\alias{any_unitbundle_ops}
\alias{list_unitbundle_ops}
\alias{unitbundle_any_ops}
\alias{unitbundle_comparison}
\alias{unitbundle_list_ops}
\alias{unitbundle_logic}
\alias{unitbundle_ops}
\title{Operations on unitbundles}
\usage{
\S4method{Arith}{unitbundle,unitbundle}(e1, e2)

\S4method{Compare}{unitbundle,unitbundle}(e1, e2)

\S4method{Logic}{unitbundle,unitbundle}(e1, e2)

\S4method{Ops}{unitbundle,ANY}(e1, e2)

\S4method{Ops}{ANY,unitbundle}(e1, e2)

\S4method{Ops}{unitbundle,list}(e1, e2)

\S4method{Ops}{list,unitbundle}(e1, e2)
}
\description{
When data with units are combined by arithmetic operations, the units ought
to be propagated through according to standard rules. Data that are
\code{unitted} obey these rules. To make this possible, the units themselves
(as \code{unitbundle} objects) also obey rules relevant to units propagation,
but be warned - the rules are slightly different for \code{unitbundle}
objects than they are for \code{unitted} objects. See \strong{Details |
Arithmetic on unitbundles}.

When data with units are compared, the units ought
to be considered according to standard rules. Data that are
\code{unitted} obey these rules. To make this possible, the units themselves
(as \code{unitbundle} objects) also obey rules relevant to comparison,
but be warned - the rules are slightly different for \code{unitbundle}
objects than they are for \code{unitted} objects. See \strong{Details |
Comparisons of unitbundles}.

It is not clear what it would mean to perform logical operations on
unitbundles; for this reason, methods in the \code{Logic} group throw errors
when applied to unitbundles.

Arithmetic and comparison operations can sometimes be done on a unitbundle
and an object of another type. This is most important for raising a
unitbundle e1 to a power e2, which actually \emph{requires} that e2 be a
number, not a unitbundle. Another useful feature of unitbundle operations is
that operation on a unitbundle and a list is conducted elementwise over the
entire list. See \strong{Details | Operations combining unitbundles and
non-unitbundles}.
}
\details{
The rules for operations on unitbundles are described in the following
subsections.

\subsection{Arithmetic on unitbundles}{

\describe{

\item{+e1, -e1, !e1}{Returns the original units of e1, which are unchanged by
these unary operations.}

\item{e1+e2, e1-e2}{e1 and e2 are required to contain identical units (an
error is thrown otherwise); the units of e1 (or, equivalently, e2) are
returned unaltered.}

\item{e1*e2}{Returns a new unitbundle containing the union (product) of all
units in e1 and e2.}

\item{e1/e2}{Returns a new unitbundle with the units of e1 in the numerator
and the units of e2 in the denominator.}

\item{e1^e2}{Requires that e2 contain no units; the new units must be
calculated with respect to the data attached to e2 but cannot be calculated
here because the data are unavailable to unitbundles themselves. The units of
e1 are returned.}

\item{e1\%\%e2}{Returns the units of e1 regardless of the units of e2.}

\item{e1\%/\%e2}{Returns the same units as e1/e2.}

}

}

\subsection{Comparisons of unitbundles}{

\describe{

\item{e1==e2}{True if e1 and e2 are identical.}

\item{e1!=e2}{True if e1 and e2 are anything but identical.}

\item{>, <, >=, <=}{Undefined for unitbundles.}

}

}

\subsection{Operations combining unitbundles and non-unitbundles}{

\describe{

\item{\code{Ops(e1,e2)} - default}{In general, if one of e1 and e2 is a
unitbundle and the other is not, the non-unitbundle is replaced by an empty
unitbundle and the operation proceeds.}

\item{\code{Ops(e1,e2)} - lists}{If the non-unitbundle is a list, the
operation is performed on the unitbundle and each element of the list.}

\item{e1^e2}{If e1 is a unitbundle and e2 is numeric, the units in e1 are
raised to the power in e2.}

}

}
}
\seealso{
\code{\link{unitbundle}} for the \code{unitbundle} class;
  \code{\linkS4class{unitted}} for data with unitbundles attached
}

